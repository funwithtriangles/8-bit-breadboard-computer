#define SHIFT_DATA 2
#define SHIFT_CLOCK 3
#define SHIFT_LATCH 4
#define EEPROM_D0 5
#define EEPROM_D7 12
#define WRITE_EN 13

#define PROG_SIZE 256

void setAddress(int address, bool outputEnable) {
  shiftOut(SHIFT_DATA, SHIFT_CLOCK, MSBFIRST, (address >> 8) | (outputEnable ? 0x00 : 0x80 ));
  shiftOut(SHIFT_DATA, SHIFT_CLOCK, MSBFIRST, address);

  digitalWrite(SHIFT_LATCH, LOW);
  delayMicroseconds(1);
  digitalWrite(SHIFT_LATCH, HIGH);
  delayMicroseconds(1);
  digitalWrite(SHIFT_LATCH, LOW);
}

byte readEEPROM(int address) {
  for (int pin = EEPROM_D0; pin <= EEPROM_D7; pin += 1) {
    pinMode(pin, INPUT);
  }
  setAddress(address, true);

  byte data = 0;
  for (int pin = EEPROM_D7; pin >= EEPROM_D0; pin -= 1) {
    data = (data << 1) + digitalRead(pin);
  }
  return data;
}
/*
   Poll D7 (MSB) until it matches the MSB of data being written
   as this indicates a completed write
*/
void pollForWriteCompletion(byte data) {
  pinMode(EEPROM_D7, INPUT);
  byte currentMSB = 0;
  byte dataMSB = data & 0x80;

  do {
    currentMSB = digitalRead(EEPROM_D7) << 7;
    delay(10);
  } while ( currentMSB != dataMSB );
}

/*
   Write a byte to the EEPROM at the specified address.
*/
void writeEEPROM(int address, byte data) {
  setAddress(address, /*outputEnable*/ false);
  for (int pin = EEPROM_D0; pin <= EEPROM_D7; pin += 1) {
    pinMode(pin, OUTPUT);
  }

  byte dataToWrite = data; // don't modify parameter
  for (int pin = EEPROM_D0; pin <= EEPROM_D7; pin += 1) {
    digitalWrite(pin, dataToWrite & 1);
    dataToWrite = dataToWrite >> 1;
  }
  digitalWrite(WRITE_EN, LOW);
  delayMicroseconds(10);
  digitalWrite(WRITE_EN, HIGH);

  pollForWriteCompletion(data);
}

/*
   Read the contents of the EEPROM and print them to the serial monitor.
*/
void printContents(int startAddress) {
  for (int address = startAddress; address < startAddress + PROG_SIZE; address++) {
    byte data = readEEPROM(address);
    Serial.println(data, BIN);
  }
}

byte progs[][PROG_SIZE] = {
  // up_down.txt
  {
0b00001000,
0b00000000,
0b00000000,
0b01101001,
0b00000000,
0b00001101,
0b00001010,
0b00000111,
0b00001110,
0b00000011,
0b01010110,
0b00000000,
0b01110110,
0b00000000,
0b00001100,
0b00000011,
0b00000111,
0b00001110,
0b00001010,
  },
  // show_image.txt
  { 
0b00001000, // 00000000: PTM
0b00000000, // 00000001: 0
0b00000000, // 00000010: b00000000
0b00001000, // 00000011: PTM
0b00000001, // 00000100: 1
0b01100110, // 00000101: b01100110
0b00001000, // 00000110: PTM
0b00000010, // 00000111: 2
0b01100110, // 00001000: b01100110
0b00001000, // 00001001: PTM
0b00000011, // 00001010: 3
0b00000000, // 00001011: b00000000
0b00001000, // 00001100: PTM
0b00000100, // 00001101: 4
0b00000000, // 00001110: b00000000
0b00001000, // 00001111: PTM
0b00000101, // 00010000: 5
0b01000010, // 00010001: b01000010
0b00001000, // 00010010: PTM
0b00000110, // 00010011: 6
0b01111110, // 00010100: b01111110
0b00001000, // 00010101: PTM
0b00000111, // 00010110: 7
0b00000000, // 00010111: b00000000
0b00001000, // 00011000: PTM
0b00001000, // 00011001: 8
0b00000000, // 00011010: b00000000
0b00001000, // 00011011: PTM
0b00001001, // 00011100: 9
0b01100110, // 00011101: b01100110
0b00001000, // 00011110: PTM
0b00001010, // 00011111: 10
0b01100110, // 00100000: b01100110
0b00001000, // 00100001: PTM
0b00001011, // 00100010: 11
0b00000000, // 00100011: b00000000
0b00001000, // 00100100: PTM
0b00001100, // 00100101: 12
0b00000000, // 00100110: b00000000
0b00001000, // 00100111: PTM
0b00001101, // 00101000: 13
0b01000010, // 00101001: b01000010
0b00001000, // 00101010: PTM
0b00001110, // 00101011: 14
0b01111110, // 00101100: b01111110
0b00001000, // 00101101: PTM
0b00001111, // 00101110: 15
0b00000000, // 00101111: b00000000
0b00001000, // 00110000: PTM
0b00001111, // 00110001: currLine
0b00001111, // 00110010: 15
0b00001001, // 00110011: RLA
0b00001111, // 00110100: currLine
0b00001011, // 00110101: OTD
0b00000001, // 00110110: LDA
0b00001111, // 00110111: currLine
0b01010110, // 00111000: ALU_DEC
0b00000000, // 00111001: 0
0b00001100, // 00111010: JE
0b01000000, // 00111011: end
0b00000011, // 00111100: STA
0b00001111, // 00111101: currLine
0b00001110, // 00111110: J
0b00110011, // 00111111: loop
0b00001111, // 01000000: HLT
  },
  // Show lines of image stored in address 0 - 7 and scroll horizontally
  {
    0b00001000, // PTM (put a 7 in address 15)
    0b00001111, //   15
    0b00000111, //   7
    0b00001001, // RFA (load A with byte from address referenced in 15)
    0b00001111, //   15
    0b00111100, // ROT (rotate the line by one)
    0b00001010, // RSA (store A into address referenced in 15)
    0b00001111, //   15
    0b00001011, // OUTD
    0b00000001, // LDA (load A with address stored at 15)
    0b00001111, //   15
    0b01010110, // DEC (decrement A)
    0b00000000, //   0 
    0b00001100, // JE (jump if 0)
    0b00000000, //   0
    0b00000011, // STA
    0b00001111, //   15
    0b00001110, // J (jump to line 3)
    0b00000011, //   3
  },
  // popcount_test.txt
  {
    0b00001000,
    0b00001111,
    0b00000111,
    0b00001000,
    0b00001110,
    0b00000000,
    0b00001001,
    0b00001111,
    0b00001011,
    0b01000000,
    0b00000111,
    0b00011001,
    0b00001110,
    0b00000011,
    0b00001110,
    0b00000001,
    0b00001111,
    0b01010110,
    0b00000000,
    0b00001100,
    0b00011001,
    0b00000011,
    0b00001111,
    0b00001110,
    0b00000110,
    0b00000001,
    0b00001110,
    0b00000111,
    0b00001111,
  },
  // neighbours.txt
  {
0b00001000,
0b00001111,
0b00001000,
0b00001000,
0b00001101,
0b10000010,
0b00001000,
0b00001100,
0b10000011,
0b00001000,
0b00001001,
0b00000111,
0b00001000,
0b00001000,
0b00000000,
0b00000001,
0b00001111,
0b01010110,
0b00000000,
0b01110110,
0b00001000,
0b00001100,
0b01011111,
0b00000011,
0b00001111,
0b00001000,
0b00001110,
0b00000111,
0b00001000,
0b00001011,
0b00000000,
0b00001001,
0b00001111,
0b10011011,
0b00001101,
0b01000000,
0b00011001,
0b00001011,
0b00000011,
0b00001011,
0b00000001,
0b00001111,
0b01101001,
0b00000000,
0b10011011,
0b00001001,
0b00000011,
0b00001010,
0b00001001,
0b00001010,
0b10011011,
0b00001100,
0b01000000,
0b00011001,
0b00001011,
0b00000011,
0b00001011,
0b00000001,
0b00001111,
0b01010110,
0b00000000,
0b10011011,
0b00001001,
0b00000011,
0b00001010,
0b00001001,
0b00001010,
0b10011011,
0b00001100,
0b01000000,
0b00011001,
0b00001011,
0b00000111,
0b00000001,
0b00001101,
0b00111100,
0b00000011,
0b00001101,
0b00000001,
0b00001100,
0b00111100,
0b00000011,
0b00001100,
0b00000001,
0b00001110,
0b01010110,
0b00000000,
0b01110110,
0b00001000,
0b00001100,
0b00001111,
0b00000011,
0b00001110,
0b00001110,
0b00011100,
0b00001111,
  },
// gol.txt
  {
0b00001000, // 00000000: PTM
0b00001000, // 00000001: currRow
0b00001000, // 00000010: 8
0b00001000, // 00000011: PTM
0b00001010, // 00000100: maskEdges
0b10000010, // 00000101: b10000010
0b00001000, // 00000110: PTM
0b00001011, // 00000111: maskFull
0b10000011, // 00001000: b10000011
0b00001000, // 00001001: PTM
0b00001100, // 00001010: maskOne
0b00000001, // 00001011: b00000001
0b00001000, // 00001100: PTM
0b00001111, // 00001101: modMask
0b00000111, // 00001110: b00000111
0b00001000, // 00001111: PTM
0b00010000, // 00010000: neg1
0b11111111, // 00010001: b11111111
0b00001000, // 00010010: PTM
0b00010001, // 00010011: nAliveDead
0b00000011, // 00010100: 3
0b00001000, // 00010101: PTM
0b00010010, // 00010110: nAlive
0b00000010, // 00010111: 2
0b00001000, // 00011000: PTM
0b00011100, // 00011001: one
0b00000001, // 00011010: 1
0b00001000, // 00011011: PTM
0b00001000, // 00011100: currRow
0b00001000, // 00011101: 8
0b00001000, // 00011110: PTM
0b00010011, // 00011111: lineBuild
0b00000000, // 00100000: b00000000
0b00000001, // 00100001: LDA
0b00001000, // 00100010: currRow
0b01010110, // 00100011: ALU_DEC
0b00000000, // 00100100: 0
0b01110110, // 00100101: ALU_CMP
0b00010000, // 00100110: neg1
0b00001100, // 00100111: JE
0b10011011, // 00101000: copyFrame
0b00000011, // 00101001: STA
0b00001000, // 00101010: currRow
0b00001000, // 00101011: PTM
0b00001001, // 00101100: currCol
0b00000111, // 00101101: 7
0b00001000, // 00101110: PTM
0b00001101, // 00101111: currCount
0b00000000, // 00110000: 0
0b00001001, // 00110001: RLA
0b00001000, // 00110010: currRow
0b10011011, // 00110011: ALU_AND
0b00001010, // 00110100: maskEdges
0b01000000, // 00110101: ALU_POP
0b00011001, // 00110110: ALU_ADD
0b00001101, // 00110111: currCount
0b00000011, // 00111000: STA
0b00001101, // 00111001: currCount
0b00000001, // 00111010: LDA
0b00001000, // 00111011: currRow
0b01101001, // 00111100: ALU_INC
0b00000000, // 00111101: 0
0b10011011, // 00111110: ALU_AND
0b00001111, // 00111111: modMask
0b00000011, // 01000000: STA
0b00001110, // 01000001: temp
0b00001001, // 01000010: RLA
0b00001110, // 01000011: temp
0b10011011, // 01000100: ALU_AND
0b00001011, // 01000101: maskFull
0b01000000, // 01000110: ALU_POP
0b00011001, // 01000111: ALU_ADD
0b00001101, // 01001000: currCount
0b00000011, // 01001001: STA
0b00001101, // 01001010: currCount
0b00000001, // 01001011: LDA
0b00001000, // 01001100: currRow
0b01010110, // 01001101: ALU_DEC
0b00000000, // 01001110: 0
0b10011011, // 01001111: ALU_AND
0b00001111, // 01010000: modMask
0b00000011, // 01010001: STA
0b00001110, // 01010010: temp
0b00001001, // 01010011: RLA
0b00001110, // 01010100: temp
0b10011011, // 01010101: ALU_AND
0b00001011, // 01010110: maskFull
0b01000000, // 01010111: ALU_POP
0b00011001, // 01011000: ALU_ADD
0b00001101, // 01011001: currCount
0b01110110, // 01011010: ALU_CMP
0b00010001, // 01011011: nAliveDead
0b00001100, // 01011100: JE
0b01111011, // 01011101: makeCellLive
0b01110110, // 01011110: ALU_CMP
0b00010010, // 01011111: nAlive
0b00001100, // 01100000: JE
0b10010000, // 01100001: checkCellAlive
0b00000001, // 01100010: LDA
0b00001010, // 01100011: maskEdges
0b00111100, // 01100100: ALU_ROT
0b00000011, // 01100101: STA
0b00001010, // 01100110: maskEdges
0b00000001, // 01100111: LDA
0b00001011, // 01101000: maskFull
0b00111100, // 01101001: ALU_ROT
0b00000011, // 01101010: STA
0b00001011, // 01101011: maskFull
0b00000001, // 01101100: LDA
0b00001100, // 01101101: maskOne
0b00111100, // 01101110: ALU_ROT
0b00000011, // 01101111: STA
0b00001100, // 01110000: maskOne
0b00000001, // 01110001: LDA
0b00001001, // 01110010: currCol
0b01010110, // 01110011: ALU_DEC
0b00000000, // 01110100: 0
0b00001100, // 01110101: JE
0b10000011, // 01110110: sendLine
0b00000011, // 01110111: STA
0b00001001, // 01111000: currCol
0b00001110, // 01111001: J
0b00101110, // 01111010: loopCol
0b00000001, // 01111011: LDA
0b00010011, // 01111100: lineBuild
0b00011001, // 01111101: ALU_ADD
0b00001100, // 01111110: maskOne
0b00000011, // 01111111: STA
0b00010011, // 10000000: lineBuild
0b00001110, // 10000001: J
0b01100010, // 10000010: rotMasks
0b00000101, // 10000011: PTA
0b00010100, // 10000100: tempLines
0b00011001, // 10000101: ALU_ADD
0b00001000, // 10000110: currRow
0b00000011, // 10000111: STA
0b00001110, // 10001000: temp
0b00000001, // 10001001: LDA
0b00010011, // 10001010: lineBuild
0b00001010, // 10001011: RSA
0b00001110, // 10001100: temp
0b00001011, // 10001101: OTD
0b00001110, // 10001110: J
0b00011110, // 10001111: loopRow
0b00001001, // 10010000: RLA
0b00001000, // 10010001: currRow
0b10011011, // 10010010: ALU_AND
0b00001100, // 10010011: maskOne
0b01000000, // 10010100: ALU_POP
0b01110110, // 10010101: ALU_CMP
0b00011100, // 10010110: one
0b00001100, // 10010111: JE
0b01111011, // 10011000: makeCellLive
0b00001110, // 10011001: J
0b01100010, // 10011010: rotMasks
0b00001000, // 10011011: PTM
0b00001000, // 10011100: currRow
0b00001000, // 10011101: 8
0b00000001, // 10011110: LDA
0b00001000, // 10011111: currRow
0b01010110, // 10100000: ALU_DEC
0b00000000, // 10100001: 0
0b01110110, // 10100010: ALU_CMP
0b00010000, // 10100011: neg1
0b00001100, // 10100100: JE
0b00011011, // 10100101: loopFrame
0b00000011, // 10100110: STA
0b00001000, // 10100111: currRow
0b01011001, // 10101000: ALU_ADD_Q
0b00010100, // 10101001: tempLines
0b00000011, // 10101010: STA
0b00001110, // 10101011: temp
0b00001001, // 10101100: RLA
0b00001110, // 10101101: temp
0b00001010, // 10101110: RSA
0b00001000, // 10101111: currRow
0b00001110, // 10110000: J
0b10011110, // 10110001: loopCopy
  }
};

void setup() {  
  pinMode(SHIFT_DATA, OUTPUT);
  pinMode(SHIFT_CLOCK, OUTPUT);
  pinMode(SHIFT_LATCH, OUTPUT);

  digitalWrite(WRITE_EN, HIGH);
  pinMode(WRITE_EN, OUTPUT);

  Serial.begin(57600);

  delay(3000);

  int numProgs = sizeof(progs) / sizeof(progs[0]);

  for (int p = 0; p < numProgs; p++) {
    Serial.println("Adding prog");
    int startAddress = p * PROG_SIZE;
    for (int l = 0; l < PROG_SIZE; l++) {
      int address = startAddress + l;
      writeEEPROM(address, progs[p][l]);
    }
    printContents(startAddress);
  }
    
 Serial.println(" done");

  
}

void loop() {

}
