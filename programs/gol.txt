; Count all 8 neighbours for each cell (mem 0-7)

$currRow=8
$currCol=9
$maskEdges=10
$maskFull=11
$maskOne=12
$currCount=13
$temp=14
$modMask=15
$neg1=16
$nAliveDead=17
$nAlive=18
$lineBuild=19
$tempLines=20

init:
  PTM currRow 8
  ; These bitmasks get the neighbours, we rotate them for each col
  PTM maskEdges b10000010
  PTM maskFull b10000011
  PTM maskOne b00000001
  ; This mask is used to make sure the rows wrap 
  ; when checking above and below for neighbours
  PTM modMask b00000111
  PTM neg1 b11111111
  PTM nAliveDead 3
  PTM nAlive 2
loopRow:
  PTM lineBuild b00000000
  LDA currRow
  ALU_DEC 0
  ALU_CMP neg1
  JE end
  STA currRow
  PTM currCol 7
loopCol:
  PTM currCount 0 ; Reset neighbour count to 0

  ; left and right neighbours
  RLA currRow
  ALU_AND maskEdges
  ALU_POP
  ALU_ADD currCount
  STA currCount

  ; top neighbours, get row above
  LDA currRow
  ALU_INC 0
  ALU_AND modMask ; loop round if we've gone higher than 7
  STA temp
  RLA temp ; Having to store and retrieve to use RLA
  ALU_AND maskFull
  ALU_POP
  ALU_ADD currCount
  STA currCount

  ; bottom neighbours, get row below
  LDA currRow
  ALU_DEC 0
  ALU_AND modMask ; loop round if we've gone lower than 0
  STA temp
  RLA temp ; Having to store and retrieve to use RLA
  ALU_AND maskFull
  ALU_POP
  ALU_ADD currCount

  ; If count === 3, then cell stays alive
  ALU_CMP nAliveDead
  JE makeCellLive

rotMasks:
  ; Rotate the masks
  LDA maskEdges
  ALU_ROT
  STA maskEdges
  LDA maskFull
  ALU_ROT
  STA maskFull
  LDA maskOne
  ALU_ROT
  STA maskOne

  ; Move along a column or jump to next row if at end
  LDA currCol
  ALU_DEC 0
  JE sendLine
  STA currCol
  J loopCol

makeCellLive:
  ; ADD the single mask bit with the line we're building up
  LDA lineBuild
  ALU_ADD maskOne
  STA lineBuild
  J rotMasks

sendLine:
  ; Send the line to display and temp line in mem
  PTA tempLines
  ALU_ADD currRow
  STA temp
  LDA lineBuild
  RSA temp 
  OTD
  J loopRow

end:
  HLT